rules_version = '2';

/**
 * # Firestore Security Rules for SocraticAI
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership model. All data is considered private
 * and is accessible only to the authenticated user who owns it. The security model
 * is designed to be simple, secure, and performant by leveraging Firestore's path
 * hierarchy to represent data ownership.
 *
 * ## Data Structure
 * All application data is stored within a top-level `users` collection. Each user's
 * data is siloed under a document whose ID matches their Firebase Authentication UID.
 * This creates a clear and secure data boundary for each user.
 *   - `/users/{userId}`: Stores the user's profile information.
 *   - `/users/{userId}/sessions/{sessionId}`: Stores the user's private tutoring sessions.
 *
 * ## Key Security Decisions
 * - **No Public Data**: All data is private. There are no publicly readable collections.
 * - **User Silos**: A user can only read or write data within their own document tree
 *   (i.e., `/users/{their-own-uid}/...`).
 * - **No User Enumeration**: Listing the top-level `users` collection is explicitly
 *   disallowed to prevent leaking user information.
 * - **Self-Creation**: Authenticated users are permitted to create their own user
 *   profile document, enabling a simple sign-up flow.
 *
 * ## Denormalization for Authorization
 * The path-based security model (`/users/{userId}`) means that authorization can be
 * determined from the document path alone, without needing to read the document's
 * contents. This is highly efficient. The rules enforce that any internal 'userId'
 * fields within documents must match the path, ensuring data integrity and preventing
 * a document from being associated with the wrong user.
 *
 * ## Structural Segregation
 * This pattern is not required as the application does not have a mix of public and
 * private data. All user data is inherently private and stored within user-specific
 * subcollections.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the signed-in user's UID matches the requested userId.
     * This is the fundamental check for user-owned data.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists and the user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the user document being created contains an `id` field
     * that matches the user's auth UID. This enforces relational integrity.
     */
    function isValidUserCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates that the user's unique `id` is not being changed on update.
     * This enforces immutability for critical relational fields.
     */
    function isImmutableUserUpdate() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that the session document being created contains a `userId` field
     * that matches the user's auth UID from the path.
     */
    function isValidSessionCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Validates that the session's `userId` field is not being changed on update,
     * preventing a session from being reassigned to another user.
     */
    function isImmutableSessionUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages user profile documents. A user can create, read, update,
     * and delete their own profile, but cannot see or list other users' profiles.
     * @path /users/{userId}
     * @allow (create) An authenticated user with UID 'user_abc' can create a document at `/users/user_abc`.
     * @deny (list) An authenticated user cannot list documents in the `/users` collection.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && isValidUserCreate(userId);
      allow update: if isExistingOwner(userId) && isImmutableUserUpdate();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's private tutoring sessions. Access is completely
       * restricted to the user who owns the parent user document.
       * @path /users/{userId}/sessions/{sessionId}
       * @allow (create) An authenticated user 'user_abc' can create a new session document in their own `/users/user_abc/sessions` subcollection.
       * @deny (get) An authenticated user 'user_xyz' cannot read a session document at `/users/user_abc/sessions/session_123`.
       * @principle Enforces strict data ownership within a user's private subcollection.
       */
      match /sessions/{sessionId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isValidSessionCreate(userId);
        allow update: if isExistingOwner(userId) && isImmutableSessionUpdate();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}